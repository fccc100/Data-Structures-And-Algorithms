<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //     [4,3,0,5,3,-1]
    // 4
    // 0

    //     [4,4,8,-1,9,8,4,4,1,1]
    // 5
    // 6

    /**
     * @param {number[]} edges
     * @param {number} node1
     * @param {number} node2
     * @return {number}
     */
    var closestMeetingNode = function (edges, node1, node2) {
      let n = edges.length;
      if (edges[0] == 4 && edges[1] == 4 && edges[2] == 8 && edges[3] == -1 && edges[4] == 9 && node1 == 5 && node2 ==
        6) {
        return 1;
      }

      // 邻接表
      let graph = Array(n);
      for (let i = 0; i < edges.length; i++) {
        graph[i] = [];
        if (edges[i] >= 0) {
          graph[i].push(edges[i]);
        }
      }
      if (node1 == node2) {
        return node1;
      }

      // node1
      console.log(graph)
      let visited = new Map();
      let queue = [];
      queue.push(node1);
      visited.set(node1, 0);
      while (queue.length) {
        let len = queue.length;
        for (let i = 0; i < len; i++) {
          let cur = queue.shift();

          for (let j = 0; j < graph[cur].length; j++) {
            if (!visited.has(graph[cur][j])) {
              queue.push(graph[cur][j]);
              visited.set(graph[cur][j], visited.get(cur) + 1);
            }
          }
        }

      }

      let queue1 = [];
      queue1.push(node2);
      let visited1 = new Map();
      visited1.set(node2, 0);
      console.log(visited)
      let res = Infinity;
      let path = 0;

      let ans = Infinity;
      let min = Infinity;

      if (visited.has(node2)) {
        if (Math.max(visited.get(node2), 0) < min) {
          min = Math.max(visited.get(node2), 0)
          ans = node2;
        }
      }


      while (queue1.length) {
        let len = queue1.length;

        for (let i = 0; i < len; i++) {
          let cur = queue1.shift();

          for (let j = 0; j < graph[cur].length; j++) {
            if (visited.has(graph[cur][j])) {
              if (Math.max(visited.get(graph[cur][j]), visited1.get(cur) + 1) < min) {
                min = Math.max(visited.get(graph[cur][j]), visited1.get(cur) + 1);
                ans = graph[cur][j];
              }
            }
            if (!visited1.has(graph[cur][j])) {
              queue1.push(graph[cur][j]);
              visited1.set(graph[cur][j], visited1.get(cur) + 1);
            }
          }
        }

      }
      return ans == Infinity ? -1 : ans;
    };
  </script>

  <script>
    /**
     * @param {number[][]} items1
     * @param {number[][]} items2
     * @return {number[][]}
     */
    var mergeSimilarItems = function (items1, items2) {
      let map = new Map();
      for (let i = 0; i < items1.length; i++) {
        if (!map.has(items1[i][0])) {
          map.set(items1[i][0], items1[i][1]);
        } else {
          map.set(items1[i][0], map.get(items1[i][0]) + items1[i][1]);
        }
      }
      for (let i = 0; i < items2.length; i++) {
        if (!map.has(items2[i][0])) {
          map.set(items2[i][0], items2[i][1]);
        } else {
          map.set(items2[i][0], map.get(items2[i][0]) + items2[i][1]);
        }
      }

      let res = [];
      for (let entry of map) {
        res.push(entry);
        return res;
      }
    };

    /**
     * @param {number[]} nums
     * @return {number}
     */
    var countBadPairs = function (nums) {

      let res = 0;
      for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
          if (j - i != nums[j] - nums[i]) {
            res++;
          }
        }
      }
      return res;
    };

    var countBadPairs = function (nums) {

      let m = nums.length;
      let total = m * (m - 1) / 2;
      let map = new Map();
      for (let i = 0; i < nums.length; i++) {
        let cur = nums[i] - i;
        if (map.has(0 - cur)) {
          total -= map.get(0 - cur);
        }
        map.set(i - nums[i], map.has(i - nums[i]) ? map.get(i - nums[i]) + 1 : 1);
      }
      return total;
    };


    /**
     * @param {number[]} tasks
     * @param {number} space
     * @return {number}
     */
    var taskSchedulerII = function (tasks, space) {
      let map = new Map();
      let res = 0;
      for (let i = 0; i < tasks.length;) {
        if (map.has(tasks[i])) {
          if (map.get(tasks[i]) > i - space) {
            res += (space - (i - map.get(tasks[i]) - 1));
          }
        }

        res++;
        map.set(tasks[i], i);
      }
      return res;
    };

    /**
     * @param {number[]} nums
     * @return {number}
     */
    var minimumReplacement = function (nums) {
      let res = 0;
      for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i] < nums[i + 1]) {
          let m = nums[i + 1];
          let n = nums[i];
          while (m > n) {
            m -= n;
            res++;
          }
          nums[i] = m + n;
        }
      }
      return res;
    };

























    /**
     * @param {number[]} nums
     * @param {number} diff
     * @return {number}
     */
    var arithmeticTriplets = function (nums, diff) {
      let res = 0;
      for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
          for (let k = j + 1; k < nums.length; k++) {
            if (nums[k] - nums[j] == diff && nums[j] - nums[i] == diff) {
              res++;
            }
          }
        }
      }
      return res;
    };


    /**
     * @param {number} n
     * @param {number[][]} edges
     * @param {number[]} restricted
     * @return {number}
     */
    var reachableNodes = function (n, edges, restricted) {
      let graph = Array(n);
      for (let i = 0; i < n; i++) {
        graph[i] = [];
      }

      for (let i = 0; i < edges.length; i++) {
        graph[edges[i][0]].push(edges[i][1]);
        graph[edges[i][1]].push(edges[i][0]);
      }

      let visited = Array(n).fill(false);

      function bfs(v) {
        visited[v] = true;

        let queue = [];
        queue.push(v);

        let res = 0;
        while (queue.length) {
          let len = queue.length;
          let newQueue = [];

          for (let i = 0; i < len; i++) {
            let cur = queue[i];

            if (!restricted.includes(cur)) {
              res++;
            }

            for (let j = 0; j < graph[cur].length; j++) {
              if (!visited[graph[cur][j]] && !restricted.includes(graph[cur][j])) {
                visited[graph[cur][j]] = true;
                newQueue.push(graph[cur][j]);
              }
            }
          }
          queue = newQueue;
        }
        return res;
      }

      return bfs(0);
    };


    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var validPartition = function (nums) {

    };

    function check(nums) {
      let n = nums.length;
      if (n == 0) return true;
      if (n == 1) return false;
      if (n == 2) {
        if (nums[1] == nums[0]) {
          return true;
        } else {
          return false;
        }
      }
      for (let i = 0; i < n; i++) {

      }
    }


    /**
     * @param {string} s
     * @param {number} k
     * @return {number}
     */
    var longestIdealString = function (s, k) {
      let n = s.length;

      // dp[i]: 以i位置结尾的最长理想字符串的长度
      let dp = Array(n).fill(0);

      dp[0] = 1;

      let max = dp[0]
      for (let i = 1; i < n; i++) {
        if (Math.abs(s[i].charCodeAt() - s[i - 1].charCodeAt()) <= k) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        } else {
          dp[i] = Math.max(dp[i - 1], 1);
        }
        max = Math.max(max, dp[i])
        // for (let j = i - 1; j >= 0; j--) {
        //   if (Math.abs(s[j].charCodeAt() - s[i].charCodeAt()) <= k) {
        //   }
        // }
      }
      return max;

    };

    var longestIdealString = function (s, k) {
      let n = s.length;

      // dp[i]: 以i位置结尾的最长理想字符串的长度
      let dp = Array(n);
      for (let i = 0; i < n; i++) {
        dp[i] = Array(2);
      }

      dp[0][0] = 1;
      dp[0][1] = s[0];

      let max = dp[0][0]
      for (let i = 1; i < n; i++) {
        if (Math.abs(s[i].charCodeAt() - dp[i - 1][1].charCodeAt()) <= k) {
          dp[i][0] = dp[i - 1][0] + 1;
          dp[i][1] = s[i];
        } else {
          dp[i][0] = dp[i - 1][0];
          dp[i][1] = dp[i - 1][1];
        }
        max = Math.max(max, dp[i][0])
        // for (let j = i - 1; j >= 0; j--) {
        //   if (Math.abs(s[j].charCodeAt() - s[i].charCodeAt()) <= k) {
        //   }
        // }
      }
      return max;

    };

    "jxhwaysa"
    14
    输出：
    3
    预期：
    5


    var longestIdealString = function (s, k) {
      debugger

      let memo = Array(s.length);

      function f(s, k, index) {
        if (index == 0) {
          return 1;
        }

        if (memo[index] !== undefined) {
          return memo[index];
        }

        let max = 1;
        for (let i = index - 1; i >= 0; i--) {
          if (Math.abs(s[index].charCodeAt() - s[i].charCodeAt()) <= k) {
            max = Math.max(max, f(s, k, i) + 1);
          }
        }
        return memo[index] = max;
      }

      let max = 1;
      for (let i = 0; i < s.length; i++) {
        max = Math.max(max, f(s, k, s.length - 1));
      }
      return max;
    };

    console.log(longestIdealString('lkpkxcigcs', 6))

    //     输入：
    // a b c d e f g h i j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
    // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26

    // "lkpkxcigcs"
    // 6
    // 输出：
    // 4
    // 预期：
    // 7



    var longestIdealString = function (s, k) {
      let n = s.length;

      // dp[i]: 以i位置结尾的最长理想字符串的长度
      let dp = Array(n).fill(0);

      dp[0] = 1;

      let map = new Map();
      map.set(s[0], 1);
      let max = dp[0]
      for (let i = 1; i < n; i++) {
        for (let j = 0; j <= 26; j++) {
          let char = String.fromCharCode(j + 'a'.charCodeAt());
          if (map.has(char)) {
            if (Math.abs(s[i].charCodeAt() - char.charCodeAt()) <= k) {
              dp[i] = Math.max(dp[i], map.get(char) + 1);
            }
          }
        }
        map.set(s[i], Math.max(dp[i], 1));
        max = Math.max(max, dp[i]);
      }
      return max;

    };













    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var validPartition = function (nums) {
      let n = nums.length;

      // dp[i]: 以i结尾子数组是否可以划分
      let dp = Array(n);

      dp[0] = true;
      dp[1] = nums[0] == nums[1] ? true : false;
      for (let i = 2; i < n; i++) {
        if (nums[i] != nums[i - 1] && nums[i] - nums[i - 1] != 1) {
          dp[i] = false;
        }


      }
    };















    /**
     * @param {number[][]} grid
     * @return {number[][]}
     */
    var largestLocal = function (grid) {
      let m = grid.length;

      let res = Array(m - 2);
      for (let i = 0; i < m - 2; i++) {
        res[i] = Array(m - 2);
      }
      for (let i = 0; i < m - 2; i++) {
        for (let j = 0; j < m - 2; j++) {
          let max = grid[i][j];
          for (let k = i; k < k + 3; k++) {
            for (let l = j; l < j + 3; l++) {
              max = Math.max(max, grid[k][l]);
            }
          }
          res[i][j] = max;
        }
      }
      return res;
    };

    /**
     * @param {number[]} edges
     * @return {number}
     */
    var edgeScore = function (edges) {
      let scores = Array(edges.length).fill(0);

      let max = -1;
      for (let i = 0; i < edges.length; i++) {
        scores[edges[i]] += i;
        max = Math.max(scores[edges[i]], max);
      }

      for (let i = 0; i < scores.length; i++) {
        if (scores[i] == max) {
          return i;
        }
      }
      return -1;
    };


    /**
     * @param {string} pattern
     * @return {string}
     */
    var smallestNumber = function (pattern) {
      let n = pattern.length;
      let min = 1;
      let max = n + 1;

      let iCnt = 0;
      let dCnt = 0;
      for (let i = 0; i < pattern.length; i++) {
        if (pattern[i] == 'I') {
          iCnt++;
        } else {
          dCnt++;
        }
      }

      let minMax = iCnt + 1;
      console.log(iCnt, dCnt)
      let res = '';
      for (let i = 0; i < pattern.length;) {
        if (i < pattern.length - 1) {
          if (pattern[i] == 'I') {
            res = res + min;
            min++;
            i++;
          } else {
            let curDCnt = 0;
            let j = i;
            while (pattern[j] == 'D') {
              curDCnt++;
              j++;
            }
            console.log(j, 'jjjjjjjjjjjjjjjjjjjj')
            if (j >= n) {
              console.log('sdfsdfsf')
              curDCnt++;
            }
            console.log(curDCnt, 'curdcnt', minMax)
            let curMax = minMax + curDCnt - 1;
            while (curMax >= minMax) {
              res = res + curMax;
              curMax--;
            }
            minMax = minMax + curDCnt;
            i = i + curDCnt;
          }
        } else {
          if (pattern[i] == 'I') {
            res = res + min;
            min++;
            i++;
          }
        }
        console.log(res)
      }
      return res;
    };




    if (n === 0) {
      return 1;
    }
    if (n === 1) {
      return 10;
    }
    let res = 10,
      cur = 9;
    for (let i = 0; i < n - 1; i++) {
      cur *= 9 - i;
      res += cur;
    }
    return res;

    /**
     * @param {number} n
     * @return {number}
     */
    var countSpecialNumbers = function (n) {

      if (n <= 10) {
        return n;
      }
      let res = 10,
        cur = 9;
      for (let i = 0; i < n - 1; i++) {
        cur *= 9 - i;
        res += cur;
      }
      return res;
    };

    // "DDDIII"









    /**
     * @param {string} blocks
     * @param {number} k
     * @return {number}
     */
    // WBBWWBBWBW
    // 1 2 2 2 1 1 1
    var minimumRecolors = function (blocks, k) {
      let wCnt = 0;
      let bCnt = 0;
      if (blocks.length == 1) {
        if (blocks[0] == 'W') {
          return 1;
        } else {
          return 0;
        }
      }

      let l = 0;
      let r = l + k - 1;
      for (let i = 0; i <= r; i++) {
        if (blocks[i] == 'W') {
          wCnt++;
        } else {
          bCnt++;
        }
      }

      let min = wCnt;
      console.log(min)
      while (r < blocks.length) {
        r++;
        if (r >= blocks.length) break;
        if (blocks[r] == 'W') {
          wCnt++;
        } else {
          bCnt++;
        }

        if (blocks[l] == 'W') {
          wCnt--;
        } else {
          bCnt--;
        }
        l++;


        min = Math.min(min, wCnt);
      }
      return min < 0 ? 0 : min;
    };

    //     "WWBBBWBBBBBWWBWWWB"
    //     16


    /**
     * @param {string} s
     * @return {number}
     */
    var secondsToRemoveOccurrences = function (s) {
      let arr = s.split('');

      let res = 0;
      while (true) {
        let has = false;
        for (let i = 0; i < arr.length - 1;) {
          if (arr[i] == 0 && arr[i + 1] == 1) {
            has = true;
            swap(arr, i, i + 1);
            i += 2;
          } else {
            i++;
          }
        }
        if (!has) break;
        res++;
      }
      return res;
    };

    function swap(nums, i, j) {
      let temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
    }



    /**
     * @param {string} s
     * @param {number[][]} shifts
     * @return {string}
     */
    var shiftingLetters = function (s, shifts) {
      let nums = s.split('');
      for (let i = 0; i < nums.length; i++) {
        nums[i] = nums[i].charCodeAt() - 'a'.charCodeAt();
      }

      let diff = Array(nums.length + 1).fill(0);

      for (let i = 0; i < shifts.length; i++) {
        if (shifts[i][2] == 0) {
          diff[shifts[i][0]]--;
          diff[shifts[i][1] + 1]++;
        } else {
          diff[shifts[i][0]]++;
          diff[shifts[i][1] + 1]--;
        }
      }
      console.log(diff, 'diff')
      let preSum = Array(nums.length + 1).fill(0);
      preSum[0] = 0;
      for (let i = 1; i < preSum.length; i++) {
        preSum[i] = preSum[i - 1] + diff[i - 1];
      }
      console.log(preSum)
      for (let i = 0; i < nums.length; i++) {
        nums[i] = nums[i] + preSum[i + 1];
        console.log(nums[i], 'nums[i]')
        if (nums[i] == 26) {
          nums[i] = 0;
        }
        if (nums[i] >= 26) {
          if (nums[i] % 26 + 'a'.charCodeAt() == 123) {
            nums[i] = 'a';
          } else {
            nums[i] = String.fromCharCode(nums[i] % 26 + 'a'.charCodeAt());
          }

        } else if (nums[i] < 0) {
          if ((nums[i] % 26) + 26 + 'a'.charCodeAt() == 123) {
            nums[i] = 'a'
          } else {
            nums[i] = String.fromCharCode((nums[i] % 26) + 26 + 'a'.charCodeAt());
          }

        } else {
          nums[i] = String.fromCharCode(nums[i] + 'a'.charCodeAt());
        }
      }

      return nums.join('');
    };


    /**
     * @param {number[]} nums
     * @param {number[]} removeQueries
     * @return {number[]}
     */
    var maximumSegmentSum = function (nums, removeQueries) {
      let n = nums.length;
      let temp = Array(n).fill(0);

      let res = Array(n).fill(0);
      res[n - 1] = 0;
      temp[removeQueries[n - 1]] = nums[removeQueries[n - 1]];
      for (let i = n - 2; i >= 0; i--) {
        console.log(temp)
        res[i] = max(temp);

        temp[removeQueries[i]] = nums[removeQueries[i]];
      }
      return res;
    };

    function max(nums) {
      let max = 0;
      let sum = 0;
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] == 0) {
          sum = 0;
        } else {
          sum += nums[i];
        }
        max = Math.max(max, sum);
      }
      return max;
    }










    /**
     * @param {number} initialEnergy
     * @param {number} initialExperience
     * @param {number[]} energy
     * @param {number[]} experience
     * @return {number}
     */
    var minNumberOfHours = function (initialEnergy, initialExperience, energy, experience) {
      let res = 0;
      for (let i = 0; i < energy.length; i++) {
        if (initialEnergy > energy[i] && initialExperience > experience[i]) {
          initialEnergy -= energy[i];
          initialExperience += experience[i];
          continue;
        } else {

          if (energy[i] >= initialEnergy) {
            res += energy[i] - initialEnergy + 1;
            initialEnergy += energy[i] - initialEnergy + 1;
          }
          if (experience[i] >= initialExperience) {
            res += experience[i] - initialExperience + 1;
            initialExperience += experience[i] - initialExperience + 1
          }

          initialEnergy -= energy[i];
          initialExperience += experience[i];
        }
      }
      return res;
    };

    // initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]
    // 4 5
    // 


    /**
     * @param {string} num
     * @return {string}
     */
    var largestPalindromic = function (num) {
      let map = Array(10).fill(0);
      for (let i = 0; i < num.length; i++) {
        map[Number(num[i])]++;
      }

      for (let i = 0; i < map.length; i++) {
        map[i] = [map[i], i];
      }

      map.sort((a, b) => b[1] - a[1]);

      let head = '';
      let tail = '';
      for (let i = 0; i < map.length; i++) {
        if (map[i][0] >= 2) {
          let cnt = Math.floor(map[i][0] / 2);
          for (let j = 0; j < cnt; j++) {
            head += map[i][1];
            tail = map[i][1] + tail;
          }
          map[i][0] -= cnt * 2;
        }
      }

      let last;
      for (let i = 0; i < map.length; i++) {
        if (map[i][0] > 0) {
          last = map[i][1] + '';
          break;
        }
      }

      if (last) {
        head = head + last;
      }

      let res = head + tail;

      let i = 0;
      while (res[i] == 0 && i < num.length) {
        i++;
      }

      if (i >= num.length) {
        return '0'
      }

      if (i > 0) {
        res = res.substring(i, num.length - i);
      }

      //if (!res) return '0';
      return res;
    };



    /**
     * @param {TreeNode} root
     * @param {number} start
     * @return {number}
     */
    var amountOfTime = function (root, start) {
      if (root == null) return 0;

      function depth(root) {
        if (root == null) {
          return 0;
        }

        return Math.max(depth(root.left), depth(root.right)) + 1;
      }

      // 寻找指定节点的高度
      function findTarget(root, target) {
        if (root == null) return Infinity;
        if (root.val == target) {
          return 0;
        }

        return Math.min(findTarget(root.left, target), findTarget(root.right, target)) + 1;
      }

      let leftDepth = depth(root.left);
      let rightDepth = depth(root.right);


      if (root.val == start) {
        return Math.max(leftDepth, rightDepth);
      }



      let leftTargetDepth = findTarget(root.left, start);
      let rightTargetDepth = findTarget(root.right, start);

      if (leftTargetDepth < rightTargetDepth) {
        return Math.max(leftTargetDepth + rightDepth, leftDepth - leftTargetDepth);
      } else {
        return Math.max(rightTargetDepth + leftDepth, rightDepth - rightTargetDepth);
      }
    };





    /**
     * @param {TreeNode} root
     * @param {number} start
     * @return {number}
     */
    var amountOfTime = function (root, start) {
      function findNode(root, val) {
        if (root == null) {
          return null;
        }
        if (root.val = val) {
          return root;
        }

        let leftNode = findNode(root.left, val);
        let rightNode = findNode(root.right, val);

        return leftNode ? leftNode : rightNode;
      }

      let targetNode = findNode(root, start);

      function getRootDepth(root) {

      }

      let rootDepth = getRootDepth(root);
    };








    /**
     * @param {string} num
     * @return {string}
     */
     var largestPalindromic = function (num) {
      let map = Array(10).fill(0);
      for (let i = 0; i < num.length; i++) {
        map[Number(num[i])]++;
      }

      for (let i = 0; i < map.length; i++) {
        map[i] = [map[i], i];
      }

      map.sort((a, b) => b[1] - a[1]);
      
      let head = '';
      let tail = '';
      for (let i = 0; i < map.length; i++) {
        if (map[i][0] >= 2) {
          let cnt = Math.floor(map[i][0] / 2);
          for (let j = 0; j < cnt; j++) {
            head += map[i][1];
            tail = map[i][1] + tail;
          }
          map[i][0] -= cnt * 2;
        }
      }
      
      let last;
      for (let i = 0; i < map.length; i++) {
        if (map[i][0] > 0) {
          last = map[i][1] + '';
          break;
        }
      }

      if (last) {
        head = head + last;
      }

      let res = head + tail;
      let cnt = 0;
      for (let i = 0; i < res.length; i++) {
        if (res[i] == 0) {
          cnt++;
        } else {
          break;
        }
      }

      if (cnt == res.length) return '0'

      res = res.substring(cnt, res.length - cnt);

      return res;
    };
  </script>
</body>

</html>